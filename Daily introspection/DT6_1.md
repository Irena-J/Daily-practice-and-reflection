6/1

```
必定把 JVM 看完
Linux视频
```

6/5

```
恭喜你看完了 JVM 基础部分；hhhh
Linux 和 多线程高阶 
每日一题
```

6/8

```
Linux
```

6/9

```
aaaaaa 这三天你干什么了？？？？
这种情况真的差，，，，，ok
多线程高阶
每日一题
```

6/10

```
多线程高阶视频已经看完，但是收获不多，初阶的知识也很多还未总结：

进程和线程衍生出来的知识点
eg：java程序的启动流程：
java.exe进程启动：
	调用系统 api 分配进程的资源(进程是系统分配资源的最小单位)
	系统级别 C 语言 main 方法(启动一个主线程，系统级别)每个进程至少有一个线程存在，即主线程。
	initialize_JVM: 初始化 Java 虚拟机进程
	create_Vm: 根据初始化参数创建 Java 虚拟机
	启动 jvm 内部的守护线程(后台线程)：垃圾回收线程
	调用 Java 代码中 main 方法(启动 Java main线程，主线程在不停上下文语义中，代表C语言系统级别的主线程还是java级别的主线程，要根据语义来决定。一般java语义所说都是java main线程)

.start() --> Thread-0 创建态转变未就绪态，等待系统调度，调度到了转变未运行态(执行run方法中的代码)

Java 创建线程需要申请操作系统，进行系统级别的下称创建，及申请系统的调度，线程的创建时非常耗时，申请系统的调度也有一定的时间需要等待。

多线程的运行效率：
	最高效率和系统资源+线程数+单个线程执行的任务量
	
使用多线程提高效率需要考虑的因素：
	所有线程执行是并发+并行
	线程创建、销毁是比较耗时的
	线程的调度由系统决定(线程越多，系统调度越频繁；线程由就绪态转变为与你形态，也是有性能及时间消耗)
	当个线程运行的任务量
	
线程中断：
	isInterrupted() 测试这个线程是否被中断
	interrupt() 中断这个线程
	interrupted() 测试当前线程是否中断
	以上三种都不是真实的直接中断，而是告诉某个线程，需要进行中断，具体是否要中断，由该线程自己来决定
	
线程的真实的中断方法：过期方法stop() 
	线程启动以后：中断标志位=false
	在线程运行态中，处理线程中断，需要自行通过判断中断标志位来进行中断的处理逻辑。通过方法判断：thread.isInterrupted()/Thread.interrupted()
	线程因调用 wait()/join()/sleep() 处于阻塞状态时，将线程中断，会造成：
		在这个三个阻塞方法所在的代码行，直接抛出中断异常
		在抛出异常之后，重置中断标志位=true
	static void interrupted():返回中断标志
	自定义的标志位满足不了线程处于阻塞状态时，中断操作
	
线程的安全问题：原子性、可见性、有序性
	非原子性代码(分解执行存在编译为calss文件时，也可能存在cpu执行指令)
		n++，n--，--n都不是原子性；需要分解为三条指令：从内存读取变量到CPU；修改变量；写回内存
		对象的 new 操作：
		Object obj = new Object();
		分解为三条指令：分配对象的内存、初始化对象、将对象赋值给变量
	可见性：sum++
		从主内存中将 SUM 变量赋值到线程的工作内存
		在工作内存中修改变量
		将sum变量从线程工作内存写回主内存
造成线程不安全：共享变量发生了修改的丢失(线程B的++操作，发生丢失)
	重排序:线程内代码是 JVM、CPU都进行重排序，给我们的感觉是线程内的代码是有序的，是因为重排序优化方案会保证线程内代码执行的依赖关系(线程内看自己的代码运行，都是有序的，但是看其他线程代码运行，都是无序的)
	
	
synchronized 关键字
	语法使用：
	
	静态方法上
	实例方法
	代码块
	
	进入 synchronized 代码行时，需要获取对象锁：
		获取成功：往下执行代码
		获取失败：阻塞在 synchronized 代码行
	
	退出 synchronized 代码块，或synchronized方法：
		退回对象锁
		通知JVM及系统，其他线程可以来竞争这把锁
	synchronized 加锁操作的关注点：
		对哪一个对象进行加锁-- 一个对象只有一把锁
		只有同一个对象，才会由同步互斥的作用
		同步代码块中一个时间点只有一个线程运行
		同步代码执行时间越短，性能下降也较快
```

![image-20200611231930824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200611231930824.png)

```
单例模式中双重校验锁、作用以及内部原理

多线程高阶：
CAS
乐观锁和悲观锁
创建线程的第三种方式
synchronized原理
Lock体系
AQS 的实现/应用
ThreadLocal



```



6/11

```
spring没理顺
```

6/12

```
spring理顺
编程题
blog
网络总结
测试点
python
```

![image-20200613180252584](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613180252584.png)

6/17

```
ee 和 测试 视频
```

6/18

```
mvc视频看完了

6：40起床，洗漱完后补视频
ee部分剩余的还有测试的用例
每日一题，针对之前做过的，还有剑指
```

