6/1

```
必定把 JVM 看完
Linux视频
```

6/5

```
恭喜你看完了 JVM 基础部分；hhhh
Linux 和 多线程高阶 
每日一题
```

6/8

```
Linux
```

6/9

```
aaaaaa 这三天你干什么了？？？？
这种情况真的差，，，，，ok
多线程高阶
每日一题
```

6/10

```
多线程高阶视频已经看完，但是收获不多，初阶的知识也很多还未总结：

进程和线程衍生出来的知识点
eg：java程序的启动流程：
java.exe进程启动：
	调用系统 api 分配进程的资源(进程是系统分配资源的最小单位)
	系统级别 C 语言 main 方法(启动一个主线程，系统级别)每个进程至少有一个线程存在，即主线程。
	initialize_JVM: 初始化 Java 虚拟机进程
	create_Vm: 根据初始化参数创建 Java 虚拟机
	启动 jvm 内部的守护线程(后台线程)：垃圾回收线程
	调用 Java 代码中 main 方法(启动 Java main线程，主线程在不停上下文语义中，代表C语言系统级别的主线程还是java级别的主线程，要根据语义来决定。一般java语义所说都是java main线程)

.start() --> Thread-0 创建态转变未就绪态，等待系统调度，调度到了转变未运行态(执行run方法中的代码)

Java 创建线程需要申请操作系统，进行系统级别的下称创建，及申请系统的调度，线程的创建时非常耗时，申请系统的调度也有一定的时间需要等待。

多线程的运行效率：
	最高效率和系统资源+线程数+单个线程执行的任务量
	
使用多线程提高效率需要考虑的因素：
	所有线程执行是并发+并行
	线程创建、销毁是比较耗时的
	线程的调度由系统决定(线程越多，系统调度越频繁；线程由就绪态转变为与你形态，也是有性能及时间消耗)
	当个线程运行的任务量
	
线程中断：
	isInterrupted() 测试这个线程是否被中断
	interrupt() 中断这个线程
	interrupted() 测试当前线程是否中断
	以上三种都不是真实的直接中断，而是告诉某个线程，需要进行中断，具体是否要中断，由该线程自己来决定
	
线程的真实的中断方法：过期方法stop() 
	线程启动以后：中断标志位=false
	在线程运行态中，处理线程中断，需要自行通过判断中断标志位来进行中断的处理逻辑。通过方法判断：thread.isInterrupted()/Thread.interrupted()
	线程因调用 wait()/join()/sleep() 处于阻塞状态时，将线程中断，会造成：
		在这个三个阻塞方法所在的代码行，直接抛出中断异常
		在抛出异常之后，重置中断标志位=true
	static void interrupted():返回中断标志
	自定义的标志位满足不了线程处于阻塞状态时，中断操作
	
线程的安全问题：原子性、可见性、有序性
	非原子性代码(分解执行存在编译为calss文件时，也可能存在cpu执行指令)
		n++，n--，--n都不是原子性；需要分解为三条指令：从内存读取变量到CPU；修改变量；写回内存
		对象的 new 操作：
		Object obj = new Object();
		分解为三条指令：分配对象的内存、初始化对象、将对象赋值给变量
	可见性：sum++
		从主内存中将 SUM 变量赋值到线程的工作内存
		在工作内存中修改变量
		将sum变量从线程工作内存写回主内存
造成线程不安全：共享变量发生了修改的丢失(线程B的++操作，发生丢失)
	重排序:线程内代码是 JVM、CPU都进行重排序，给我们的感觉是线程内的代码是有序的，是因为重排序优化方案会保证线程内代码执行的依赖关系(线程内看自己的代码运行，都是有序的，但是看其他线程代码运行，都是无序的)
	
	
synchronized 关键字
	语法使用：
	
	静态方法上
	实例方法
	代码块
	
	进入 synchronized 代码行时，需要获取对象锁：
		获取成功：往下执行代码
		获取失败：阻塞在 synchronized 代码行
	
	退出 synchronized 代码块，或synchronized方法：
		退回对象锁
		通知JVM及系统，其他线程可以来竞争这把锁
	synchronized 加锁操作的关注点：
		对哪一个对象进行加锁-- 一个对象只有一把锁
		只有同一个对象，才会由同步互斥的作用
		同步代码块中一个时间点只有一个线程运行
		同步代码执行时间越短，性能下降也较快
```

![image-20200611231930824](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200611231930824.png)

```
单例模式中双重校验锁、作用以及内部原理

多线程高阶：
CAS
乐观锁和悲观锁
创建线程的第三种方式
synchronized原理
Lock体系
AQS 的实现/应用
ThreadLocal



```



6/11

```
spring没理顺
```

6/12

```
spring理顺
编程题
blog
网络总结
测试点
python
```

![image-20200613180252584](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613180252584.png)

6/17

```
ee 和 测试 视频
```

6/18

```
mvc视频看完了

6：40起床，洗漱完后补视频
ee部分剩余的还有测试的用例
每日一题，针对之前做过的，还有剑指

今天没有刷题，补了两节ee，但是没有太大收获，测试用例篇完成。
```

6/19

```
web 复习、两节ee
每日一题，剑指，主要补刷题、测试用例，blog

视频看完，收获不大，ee和web欠缺很多，没有刷题，测试用例没有完成，以后的任务需要详细啊
ee 和 web 部分的内容是太难还是没学会啊，这个东西有点成谜，明天需要查一查这个，当然不能浪费整块的时间，需要用琐碎的时间考虑这个东西。
```

6/20

```
7：00 开始刷题，数据结构和算法这两个部分不够牢固，别的框架什么的可以后面慢慢学，基础知识和代码能力必须扎实，起床的第一件事情，刷题，必须刷题跟上，把动态规划这种高级的数据结构，可以先学一下，不需要立刻掌握，大宝剑上的题每天必须至少搞懂两道，加blog，然后网络、线程和JVM的知识，最近搞这个好了。


```

6/21

```
刷题一道 统计回文
测试
```

6/22

```
刷刷刷，offer 和 快排在安排，每日一题
整理 JVM 部分博客
```

6/23

```
自动化测试 实验
刷题
JVM blog

写了几篇bolg，有一个问题，你不想做的事情拖着还是要做的啊？还抗拒歌什么？
```

6/24

```
六月最后一个礼拜了，加油啊
刷题
JVM blog 完结，
准备测试实验
```

