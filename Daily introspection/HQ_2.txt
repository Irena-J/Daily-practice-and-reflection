EveryDay：

$$$ 现在就可以开始针对课件的题一个个过了
$$$	代码能力(每日选择+编程)
$$$	面经上的点 抽丝剥茧 录音回答 查漏补缺 逻辑表达

基础反复：
SE：数组、包装类、字符串、多态、接口(基本类型、包装类形参改变不影响实参)
数据库：JDBC、多表查询、内联外联

1、Uncaught (in promise) 需要在then后面加入catch()异常捕获
2、跨域问题的解决方案
3、instanceof
4、现在就可以开始针对课件的题一个个过了
5、token
6、分支管理
7、把你的博客搭起来
8、Thread是java.lang包里的类，而java.lang这个包是自动引入的，所以可以直接Thread.静态方法
9、线程创建
	一旦调用start()方法，则会通过JVM找到run()方法去执行，怎么执行自己的逻辑代码呢？
	一种是继承Thread，然后重写run方法，jvm执行的就是自己的写的run方法了。一种是传入一个target，
	然后在Thread的run方法中调用target的run方法。
	
10、那些问题会引起线程的不安全？结合多线程的特性
11、集合框架blog
12、数据库的思维导图、数据库的blog 总结 尤其是jdbc 多表操作 内联外联
13、扩容机制
14、compare 也在接口中没学扎实
15、匿名内部类：隐式的继承一个类或者实现一个接口(是一个继承了该类或者实现了该接口的子类匿名对象)
16、基础知识不要忘记回顾啊，
17、name="buton"表示这个按钮的名称叫做"button";相当于一个标识符，用于以后和后台交互，后台根据这个名称来区分是点击了哪个按钮，
	(其实这只是为了定义一种类型的按钮而已，如果没有定义，也米娜就会默认使用了name="text")
	
18、多线程几个重要问题：
	多线程有几种实现方案，分别是哪几种？
		继承Thread类
		实现Runnable接口
		实现Callable接口(和线程池结合)
	同步有几种方式
		同步代码块
		同步方法
	启动线程run() 还是start()
		start()
		run:封装了被线程执行的代码，直接调用仅仅是调用普通方法
		start：启动线程，并由JVM调用run方法
	sleep和wait方法的区别
		sleep：必须指时间，不释放锁
		wait：可以不指定时间，也可以指定，释放锁
	为什么 wait()，notify,notifyAll 等方法都定义在Object中
		因为这些方法的调用时依赖于锁对象的，而同步代码块的锁对象时任意锁
		而Object代表任意的对象都可接受，所以在这里定义。
	线程的生命周期图
		新建、就绪、运行、死亡
		新建、就绪、运行、阻塞、就绪、运行、死亡  
	
19、git clone https://~ : https 用443端口，可以对 repo 根据权限进行读写，只要有账号密码
	git clone git@github.compa~ : 也可以对 repo根据权限进行读写，但是需要 ssh key 授权，
	这个 key 是通过 ssh key 生成器生成的，然后放在github上，作为授权的证据，这样就无需用户名和密码授权了。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	