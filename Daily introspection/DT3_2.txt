3/13
blog 关于Vue安装配置和使用
	前端项目初始化步骤：
		
		node_moudules 依赖包目录
		public 		  静态资源目录
		src			  组件源码目录
		babel.congig.js	Babel 配置文件
		
		通过Vue脚手架创建项目
		配置Vue路由
		配置Element-UI组件库
		配置axios库(网络相关)
		
		导入组件库Elementui后
		//导入相关样式
		配置Vue插件
		
		创建一个登陆组件，并且以路由的形式渲染到根组件
		通过路由重定向，访问。。。自动跳转到。。
		[Vue warn]: Failed to resolve directive: moudel 无法解析指令moudel 注意是model哦
	
多线程概述、
	线程和进程
		进程：正在运行的程序，是系统进行调度和分配的独立单位，每一个进程都有自己的内存空间和系统资源
			多进程的意义：
				单进程的计算机一个事件内只能做一件事，多进程可以在同一时间段内做多件事(提高cpu的使用率)
				关于单核CPU：一边。。一边。。是同时？我们会有这样的感觉是CPU在做着程序间高效切换

		线程：进程的单个顺序控制流，是一条执行路径，
		(一个进程内可以执行多个任务，而每一个任务就可以看作一个线程，线程是进程的执行单元，执行路径)
			单线程：程序只有一条执行路径
			多线程：程序又多条执行路径
			
			多线程意义：不是提高程序的执行速度，其实为了提高应用程序的使用率
						程序的执行其实是抢CPU的资源，CPU的执行权，
						多个进程是在抢这个资源，而其中的某一个进程如果执行的路径比较多，就会又更高的几率抢占到CPU使用权
						我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性
并行：逻辑上同时发生，某一时间段内同时运行多个程序
并发：物理上同时发生，某一个时间点同时运行多个程序	

java程序的运行原理：
				由java命令启动JVM,JVM启动就相当于启动了一个进程
				接着由该进程去创建了一个主线程去调用main方法
	jvm虚拟机 的启动是单线程还是多线程？
	答：当然是多线程啦，原因是垃圾回收线程也要先启动，否则很容易栈内存溢出(垃圾回收+主线程+。。)
	
需求：如何实现一个多线程程序？
	由于线程是依赖进程而存在的，所以首先应该创建一个进程出来
	而进程是由系统创建的，应该调用系统功能程间一个进程
	java是不能直接调用系统功能的，所以，不能直接实现多线程程序
	但是java可以去调用C/C++写好的程序来实现多线程程序
	由C/C++去调用系统功能创建进程，然后由Java去调用
java提供的类：Thread，由多种方式实现多线程
	多线程的实现方案1：方式一：继承Thread类
		步骤：
			A：自定义类MyThread继承Thread类
			B：MyThread类里面重写run()方法(不是类中所有的代码都需要被线程执行的，
			   为了区分，java提供了Thread类中run()方法来包含那些被线程执行的东西)
			C：创建对象
			D：启动线程 一般来说，被线程执行的都是比较耗时的 
			   直接调用run方法是单线程的效果，相当于调用普通方法，所以要借助start方法

		class MyThread extends Thread{
			public void run() {
				//一般被线程执行的代码肯定是比较耗时的，所以里面可以写循环
				for (int x = -; x < 10; x++) {
					System.out.println(x);
				}
			}
		}
		
		public class MyThreadDemo {
			public static void main(String[] args) {
				MyThread my1 = new MyThread();
				MyThread my2 = new MyThread();
				my1.start();
				my2.start();
				
			}
		}
	问题a：为什么要重写run()方法？
		run里封装的是被线程执行的代码
		
	问题b：run和start区别？
		run：仅仅是封装线程执行的代码，直接调用是普通方法
		start：首先启动了线程，然后再由JVM去调用该线程的run方法
 
	线程调度：
		分时调度模型:所有的线程轮流使用CPU的使用权，平均分配每个程序占用CPU的时间片
		抢占式调用模型：优先让优先级高的线程使用CPU，如果线程优先级相同，那么会随机选择一个，
					优先级高的获取CPU的时间片相对多一些
		(java使用的是抢占式调度模型)

	如何获取线程对象的默认优先级：线程默认是 5 
	public final int getPriority():返回线程对象优先级
	如何设置线程对象的优先级：注意线程的优先级有极限(0-10之间 MAX_PRIORITY MIN_PRIORITY NORM_PRIORITY)
	public finel void setPriority()
	注意：
		线程优先级高仅仅表示线程获取CPU时间片的几率高，需要在比较多次的运行才可能看到效果（因为存在随机性）

 
	线程控制：
		线程休眠	public static void sleep(long millis)
		线程加入	public final void join();某个线程终止后，后面才可以进行
		线程礼让	public static void yield();暂停当前执行的线程对象，并执行其他线程(多个线程执行更和谐)
		后台线程	public final void setDaemon(boole an on);(该方法必须在启动线程前调用，该方法首先调用该线程的checkAccess方法，且不带任何参数)
		将该线程标记为守护线程或用户线程，当正在运行的线程都是守护线程时，java虚拟机退出
		线程中断	public final void stop();不建议使用，比较暴力不安全已经过时
					public void interrupt();终止线程状态并抛出interruptedException
				
	线程生命周期
		新建：创建线程对象
		就绪：有执行资格，没有执行权
		运行：有执行资格，没有执行权
				阻塞：由于一些操作让线程处于了该状态，没有执行资格，没有执行权
					  而另一些操作却可以把它唤醒，唤醒后处于就绪状态
		死亡：线程对象变成垃圾，等待被回收

	多线程的实现方案2：实现Runnable接口
			A：自定义类MyRunnable实现Runnable接口
			B: 重写 run() 方法
			C：创建MyRunnable类的对象
			D：创建Thread类的对象，并把C步的对象作为构造参数传递
			
			class MyRunnable implements Runnable {
				public void run() {
					for ( int x = 0; x < 100; x++) {
					//由于实现接口的方式就不能直接使用Thread类的方法了，但可以间接使用
						System.out.println(Thread.currentThread().getName()+":"+x);
					}
				}
			}
			
			public class MyRunnableDemo {
				public static void main(String[] args) {
					//创建MyRunnable类的对象
					MyRunnable my = new MyRunnable();
					
					//创建Thread类的对象，并把my最为构造参数传递
					Thread t1 = new Thread(my);
					Thread t2 = new Thread(my);
					
					t1.start();
					t2.strat();
				}
			}
			

		

		
	线程同步
	死锁、
	线程间通信、
	定时器的使用
	
	
	
	
	
	 二维表中，能够惟一确定记录的一个字段或几个字段的组合被称为“超关键字”。“超关键字”虽然能唯一确定记录，但是它所包含的字段可能是有多余的。
如果一个超关键字去掉其中任何一个字段后不再能唯一地确定记录，则称它为“候选关键字。候选关键字既能唯一地确定记录，它包含的字段又是最精炼的。也就是说候选关键字是最简单的超关键字。
主关键字(primary key)是表中的一个或多个字段，它的值用于唯一地标识表中的某一条记录。
比如在一张成绩表中，有字段：学号，科目，成绩，任课老师。
学号+科目+任何其他字段就是超关键字，但是如果去掉学号或者科目中的一个就无法确定成绩，所以学号和科目是两个候选关键字。
只有知道了学号和科目你才能确定一条记录，所以学号和科目两个字段组成了主关键字
	